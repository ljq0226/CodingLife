
### 动态规划
#### [72.编辑距离](https://leetcode.cn/problems/edit-distance/)
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
-   插入一个字符
-   删除一个字符
-   替换一个字符
示例 1： 输入：word1 = "horse", word2 = "ros" 输出：3 解释： horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e')
```js
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
const minDistance = (word1, word2) => {
    let dp = Array.from(Array(word1.length + 1), () => Array(word2.length+1).fill(0));
    for(let i = 1; i <= word1.length; i++) {
        dp[i][0] = i; 
    }
    for(let j = 1; j <= word2.length; j++) {
        dp[0][j] = j;
    }
    for(let i = 1; i <= word1.length; i++) {
        for(let j = 1; j <= word2.length; j++) {
            if(word1[i-1] === word2[j-1]) {
                dp[i][j] = dp[i-1][j-1];
            } else {
                dp[i][j] = Math.min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1);
            }
        }
    }
    return dp[word1.length][word2.length];
};
```
#### [115不同子序列](https://leetcode.cn/problems/distinct-subsequences/solution/)
给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。
字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）
题目数据保证答案符合 32 位带符号整数范围。
示例 1：
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
rabbbit
rabbbit
rabbbit
```js
/**
 * @param {string} s
 * @param {string} t
 * @return {number}
 */
const numDistinct = (s, t) => {
    let dp = Array.from(Array(s.length + 1), () => Array(t.length +1).fill(0));
    for(let i = 0; i <=s.length; i++) {
        dp[i][0] = 1;
    }
    for(let i = 1; i <= s.length; i++) {
        for(let j = 1; j<= t.length; j++) {
            if(s[i-1] === t[j-1]) {
                dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
            } else {
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[s.length][t.length];
};
```
#### [1402做菜顺序](https://leetcode.cn/problems/reducing-dishes/)
一个厨师收集了他 n 道菜的满意程度 satisfaction ，这个厨师做出每道菜的时间都是 1 单位时间。
一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是 time[i] * satisfaction[i] 。
请你返回做完所有菜 「喜爱时间」总和的最大值为多少。
你可以按 任意 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。
示例 1：
输入：satisfaction = [-1,-8,0,5,-9]
输出：14
解释：去掉第二道和最后一道菜，最大的喜爱时间系数和为 (-1* 1 + 0* 2 + 5* 3 = 14) 。每道菜都需要花费 1 单位时间完成。
解题思路
由题意，顺序随便来，如果你是厨子，你肯定把好货放后面压轴对不对？这样才能尽可能的打出最大“喜爱时间”。
所以，三步搞定hard：
排序
遍历左指针
遍历右指针并更新当前“喜爱时间”的最大值
```js
/**
 * @param {number[]} satisfaction
 * @return {number}
 */
const maxSatisfaction = (satis) => {
    const sortedArr = satis.sort((a,b) => a-b);     //好货压轴
    let pre = 0;
    let ans = 0;
    //暴力遍历出所有选择，在遍历右指针的时候并更新当前“喜爱时间”的最大值
    for(let i=0; i<sortedArr.length; i++){
        pre = 0;
        for(let j=i; j<sortedArr.length; j++){
            pre += sortedArr[j] * (j-i+1);
            ans = Math.max(ans, pre);
        }
    }
    return ans;
}
```
### 贪心
#### [376. 摆动序列 ](https://leetcode.cn/problems/wiggle-subsequence/)
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。
例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。
示例 1:
输入: [1,7,4,9,2,5]
输出: 6
解释: 整个序列均为摆动序列。
```js
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var wiggleMaxLength = function(nums) {
  if(nums.length <= 1) return nums.length
  let res = 1
  let preDiff = 0
  let curDiff = 0
  for(let i = 0; i < nums.length - 1; i++) {
      curDiff = nums[i + 1] - nums[i]
      if((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {
          res++
          preDiff = curDiff
      }
  }
  return res
};
/*
时间复杂度：O(n)O(n)，其中 nn 是序列的长度。我们只需要遍历该序列一次。
空间复杂度：O(1)O(1)。我们只需要常数空间来存放若干变量。
*/
```
### 分治
#### [53.最大字数组和](https://leetcode.cn/problems/maximum-subarray)
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
[解决方法](https://leetcode.cn/problems/maximum-subarray/solution/wu-chong-jie-fa-san-chong-yu-yan-java-javascript-2/)
```js
/*
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
  //贪心解法
  let res = -Infinity
  let count = 0
  for (let i = 0; i < nums.length; i++) {
    count += nums[i]
    if (count > result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置）
      result = count;
    }
    if (count <= 0) {// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
      count = 0
    }
  }
  return res
    //动态规划解法
  // let pre = 0, max = nums[0]
  // nums.map((num) => {
  //   pre = Math.max(pre + num, num)
  //   max = Math.max(max, pre)
  // })
  // return max
};
/* 分治解法
时间复杂度： O(nlogn) - n 是数组长度
空间复杂度： O(logn) - 因为调用栈的深度最多是logn。
 */
function LSS(list) {
  return helper(list, 0, list.length - 1);
}
function helper(list, m, n) {
  if (m === n) return list[m];
  let sum = 0;
  let lmax = -Number.MAX_VALUE;
  let rmax = -Number.MAX_VALUE;
  const mid = ((n - m) >> 1) + m;
  const l = helper(list, m, mid);
  const r = helper(list, mid + 1, n);
  for (let i = mid; i >= m; i--) {
    sum += list[i];
    if (sum > lmax) lmax = sum;
  }
  sum = 0;
  for (let i = mid + 1; i <= n; i++) {
    sum += list[i];
    if (sum > rmax) rmax = sum;
  }
  return Math.max(l, r, lmax + rmax);
}
console.log(LSS([-2,1,-3,4,-1,2,1,-5,4]));
```
**伪代码**
```python
uniquePathsWithObstacles(grid[0..m-1][0..n-1])
//统计从左上角到右下角的不同路径的条数
//输入:一个二维数组，代表要移动的矩阵
//输出：不同路径的条数
dp<-[0..m-1][0..n-1]
//初始化dp数组
for i<-0 to m do
    if grid[i][0]==1
        break
    dp[i][0]=1
for j<-0 to n do
    if grid[0][j]==1
        break
    dp[0][j]=1
for i<-1 to m do 
    for j<-1 to n do
        if grid[i][j]==1
           continue
        dp[i][j]<-dp[i-1][j]+dp[i][j-1]
return dp[m][n]
```
**时间复杂度分析**
算法的基本操作为双重循环内部的赋值语句
很容易得到时间复杂度为O（m* n）
**空间复杂度分析**
算法使用了二维数组来保存动态规划的中间结果
很容易得到空间复杂度为O（m* n）
本题可以使用滚动数组的思想进行优化，优化后空间复杂度为O（n）
### 回溯
#### [39.组合总和](https://leetcode.cn/problems/combination-sum/)
给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。
candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
对于给定的输入，保证和为 target 的不同组合数少于 150 个。
示例 1：
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function (candidates, target) {
  const res = []
  const path = []
  candidates.sort((a, b) => a - b)
  const dfs = (index, sum) => {
    if (sum === target) {
      res.push(Array.from(path))
      return
    }
    for (let i = index; i < candidates.length; i++) {
      const n = candidates[i]
      //如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历
      if (n > target - sum) break
      path.push(n)
      sum += n
      dfs(i, sum)
      //当满足递归终止条件时，将path[]和sum清零
      path.pop()
      sum -= n
    }
  }
  dfs(0, 0)
  return res
};
```
### 补充题目
#### 二、快递终端送货分配系统
question1伪代码：
```python
```
question2伪代码：
```python
question2(goods[0..n-1],k)
//求最少需要的趟数
//输入：goods为货物列表goods[1]为货物重量,k为每一趟最多承重量
//输出：最少需要的趟数
list<-[]
for i to n do:
    weight<-goods[i]
    min<-∞
    k<-0
    //遍历每一趟剩余可装的货物重量
    for j to list.size do:
        size<-list.get(j)
        if size-weight< min:
            min=size-weight
            k=j
    //判断是否需要增加一趟
    if min != ∞:
        remove<-list.get(k)
        list.remove(remove)
        list.add(remove-weight)
    else:
        list.add(100-weight)
//列表的长度即为总共需要的趟数
return list.size
```
question3伪代码：
```python
createHuffmanTree(value[0..n-1])
//构建哈夫曼树
//输入：节点的权值集合
//输出：哈夫曼树的根节点
nodes<-[]
for i to n:
    nodes.add(value[i])
while nodes.size>1:
    sort(nodes)
    //取出前两个权值最小的节点
    left<-nodes.get(0)
    right<-nodes.get(1)
    //创建新节点权值为两节点权值之和
    root<-left.val+right.val
    root.left<-left
    root.right<-right
    //新节点加入列表，左右子节点z
    nodes.add(root)
    nodes.remove(left)
    nodes.remove(right)
return nodes.get(0)
```
question4伪代码：
```
```
#### 三、果园篱笆
蛮力法伪代码：
```python
bruteForce(position[0..n-1])
//蛮力法解决凸包问题
//输入：position点的集合
//输出：所有极点的集合
points<-[]
for i<-0 to n do:
    for j<i+1 to n do:
        oneSide<-0
        otherSide<-0
        for k<-0 to n do:
            temp<-calculate(position[i],positon[j],position[k])
            if temp>0:
            	oneSide++
        	else if temp<0:
            	otherSide++
        if oneSide=0 or otherSide=0:
            points.add(position[i])
            points.add(positon[j])
calculate(point1,point2,point)
//计算第三个点距离前两个点形成的直线的距离
//输入：三个点的坐标
//输出：第三个点距离前两个点形成的直线的距离
x1<-point1.x
y1<-point1.y
x2<-point2.x
y2<-point2.y
x<-point.x
y<-point.y
a<-y2-y1
b<-x1-x2
c<-x1*y2-y1*x2
return a*x + b*y - c
```
分治法伪代码：
```js
const getShapeBtn = document.querySelector('.getShapeBtn')
const bruceBtn = document.querySelector('.bruce')
const alertText = document.querySelector('.alert')
const clearBtn = document.querySelector('.clearBtn')
const inputY = document.querySelectorAll('.textY')
const inputGroups = document.querySelector('.inputGroups')
const pointsDiv = document.querySelector('.pointsDiv')
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
function init(){
  const testPoints =[[50, 30], [200, 100], [300, 200], [300, 250], [300, 300], [400, 400]];
  draw(testPoints)
  const testHullPoints = convexHull(testPoints)
  drawShape(testHullPoints)
}
var points = []
init()
for (const input of inputY) {
  input.addEventListener('keydown', event => {
    if (event.key === 'Enter') {
      // 触发 enter 键盘事件
      let point = [inputGroups.children[0].value, inputGroups.children[1].value]
      point = point.map(item => +item)
      points.push(point)
      let str = ''
      for (let i = 0; i < points.length; i++) {
        str += `${i}: [${points[i]}]  `
      }
      pointsDiv.innerHTML = `${str}`
      inputGroups.children[0].value = ''
      inputGroups.children[1].value = ''
    }
  })
}
function clearCanvas() {
  const w = 500;
  const h = 500;
  canvas.width = w;
  canvas.height = h;
}
clearBtn.onclick = clearCanvas
getShapeBtn.onclick = () => {
  //绘制点
  draw(points)
  const hull = convexHull(points);
  setTimeout(() => {
    drawShape(hull)
  }, 1000);
  //绘制凸包
}
function convexHull(points) {
  // 将点按照横坐标升序排序
  points.sort((a, b) => a[0] - b[0]);
  // 通过 Andrew 算法求凸包
  const n = points.length;
  let hull = [];
  // 下凸包
  for (let i = 0; i < n; i++) {
    while (hull.length >= 2 && cross(hull[hull.length - 2], hull[hull.length - 1], points[i]) <= 0) {
      hull.pop();
    }
    hull.push(points[i]);
  }
  // 上凸包
  for (let i = n - 1, t = hull.length + 1; i >= 0; i--) {
    while (hull.length >= t && cross(hull[hull.length - 2], hull[hull.length - 1], points[i]) <= 0) {
      hull.pop();
    }
    hull.push(points[i]);
  }
  hull.pop();
  return hull;
}
// 计算向量 OA 和 OB 的叉积
function cross(O, A, B) {
  return (A[0] - O[0]) * (B[1] - O[1]) - (A[1] - O[1]) * (B[0] - O[0]);
}
function drawShape(hull) {
  ctx.beginPath();
  ctx.moveTo(hull[0][0], hull[0][1]);
  for (let i = 1; i < hull.length; i++) {
    ctx.lineTo(hull[i][0], hull[i][1]);
  }
  ctx.closePath();
  ctx.fillStyle = 'purple';
  ctx.stroke();
}
function draw(points) {
  ctx.beginPath();
  console.log(points);
  const radius = 5
  const len = points.length
  for (let i = 0; i < points.length - 1; i++) {
    ctx.arc(points[i][0], points[i][1], radius, 0, 2 * Math.PI);
    ctx.fill()
    ctx.fillStyle = 'green';
    ctx.strokeText(`[${points[i][0]} , ${points[i][1]}]`, points[i][0] + 10, points[i][1]);
    ctx.moveTo((points[i + 1][0] + radius), points[i + 1][1]);
  }
  ctx.arc(points[len - 1][0], points[len - 1][1], radius, 0, 2 * Math.PI);
  ctx.fill()
  ctx.fillStyle = 'green';
  ctx.strokeText(`${points[len - 1][0]} , ${points[len - 1][1]}`, points[len - 1][0] + 10, points[len - 1][1]);
  ctx.stroke();
}
```
#### 五、基因序列比较
动态规划伪代码：
```python
dynamicProgramming(arr1[0..m-1],arr2[0..n-1])
//动态规划求两个基因序列的最佳得分
//getScore()用于获取两个相对的碱基得分
//输入：两个字符数组，代表两个基因序列
//输出：最佳得分
dp<-[0..m][0..n]
//初始化
for i<-1 to m+1 do 
    dp[i][0]<-getScore(arr1[i-1],'-')+dp[i-1][0]
for j<-1 to n+1 do
    dp[0][j]<-getScore('-',arr2[j-1])+dp[0][j-1]
//开始状态转移
for i<-1 to m+1 do
    for j<-1 to n+1 do
		dp[i][j]<-max(
            dp[i-1][j]+getScore(arr1[i-1],'-'),
            dp[i][j-1]+getScore('-',arr2[j-1]),
            dp[i-1][j-1]+getScore(arr1[i-1],arr2[j-1])
        )
return dp[m][n]
```
时间复杂度分析：
空间复杂度分析：
```js
const SCORING_MATRIX = {
  A: { A: 5, C: -1, G: -2, T: -1, "-": -3 },
  C: { A: -1, C: 5, G: -3, T: -2, "-": -4 },
  G: { A: -2, C: -3, G: 5, T: -2, "-": -2 },
  T: { A: -1, C: -2, G: -2, T: 5, "-": -1 },
  "-": { A: -3, C: -4, G: -2, T: -1, "-": 0 }
};
const tbody = document.querySelector('.tableList')
const res_du = document.querySelector('.res_du')
const res_str = document.querySelector('.res_str')
function align(s1, s2) {
  console.log(s1, s2);
  // 初始化dp数组
  const dp = Array(s1.length + 1).fill(null).map(() => Array(s2.length + 1).fill(0));
  // 首先对第一行和第一列进行初始化
  // 因为它们都是只能从一种状态变换过来，所以直接赋值即可
  for (let i = 1; i <= s1.length; i++) {
    dp[i][0] = SCORING_MATRIX[s1[i - 1]]["-"] + dp[i - 1][0];
  }
  for (let j = 1; j <= s2.length; j++) {
    dp[0][j] = SCORING_MATRIX["-"][s2[j - 1]] + dp[0][j - 1];
  }
  // 计算dp数组
  for (let i = 1; i <= s1.length; i++) {
    for (let j = 1; j <= s2.length; j++) {
      dp[i][j] = Math.max(
        dp[i - 1][j - 1] + SCORING_MATRIX[s1[i - 1]][s2[j - 1]],
        dp[i - 1][j] + SCORING_MATRIX[s1[i - 1]]["-"],
        dp[i][j - 1] + SCORING_MATRIX["-"][s2[j - 1]]
      );
    }
  }
  showBestWay(dp, s1, s2)
  showList(dp)
  console.log(dp);
  // 返回最后一个元素的值，即最大分数
  return dp[s1.length][s2.length];
}
align("AGTGATG", "GTTAG")
// 输出最佳对齐方法
function showBestWay(dp, arr1, arr2) {
  const m = dp.length;
  const n = dp[0].length;
  const list = [];
  // 手动把终点的索引加入列表，从终点向后回溯
  list.push([m - 1, n - 1]);
  dfs(dp, arr1, arr2, m - 1, n - 1, list);
  // 使用栈倒转列表，方便从起点开始描述路径
  const stack = [];
  for (let i = 0; i < best.length; i++) {
    stack.push(best[i]);
  }
  // 双指针，分别记录两个基因序列的索引
  let index1 = 0;
  let index2 = 0;
  // 使用两个StringBuilder分别保存两个基因序列
  const sb1 = [];
  const sb2 = [];
  // 记录当前的位置，初始值为起点
  let nowX = 0;
  let nowY = 0;
  while (stack.length > 0) {
    const pop = stack.pop();
    const x = pop[0];
    const y = pop[1];
    if (x > nowX && y > nowY) { // 向右下移动了
      sb1.push(arr1[index1++]);
      sb2.push(arr2[index2++]);
    } else if (x > nowX) { // 向下移动了
      sb1.push(arr1[index1++]);
      sb2.push("-");
    } else { // 向右移动了
      sb2.push(arr2[index2++]);
      sb1.push("-");
    }
    // 更新当前位置
    nowX = x;
    nowY = y;
  }
  res_du.innerHTML = `
  ${dp[m - 1][n - 1]}
  `
  res_str.innerHTML = `
  <p class=""> ${sb1.join("")}</p>
  <p class=""> ${sb2.join("")}</p>
  `
}
function dfs(dp, arr1, arr2, x, y, list) {
  // 当列表中的元素足够多时，停止搜索
  if (list.length === dp.length - 1) {
    best = [...list];
    return;
  }
  const dirs = [[-1, 0], [0, -1], [-1, -1]];
  const s = [SCORING_MATRIX[arr1[x - 1]]['-'],
  SCORING_MATRIX['-'][arr2[y - 1]],
  SCORING_MATRIX[arr1[x - 1]][arr2[y - 1]]]
  for (let i = 0; i < dirs.length; i++) {
    const x1 = x + dirs[i][0];
    const y1 = y + dirs[i][1];
    if (x1 < 0 || y1 < 0 || dp[x][y] - s[i] !== dp[x1][y1]) {
      continue;
    }
    const temp = [x1, y1];
    list.push(temp);
    dfs(dp, arr1, arr2, x1, y1, list);
    list.pop();
  }
}
function showList(dp) {
  tbody.innerHTML = ''
  for (let i = 0; i < dp.length; i++) {
    tbody.innerHTML += `
    <tr>
    </tr>
    `
    for (let j = 0; j < dp[0].length; j++) {
      tbody.children[i].innerHTML += `
      <td>${dp[i][j]}</td>
      `
    }
  }
}
function showGene() {
  const str1 = document.querySelector('.str1')
  const str2 = document.querySelector('.str2')
  align(str1.value, str2.value)
}
document.querySelector('.gene').addEventListener('click', showGene)
```
