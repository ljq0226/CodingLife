## Leetcode选题
### 动态规划
#### [72.编辑距离](https://leetcode.cn/problems/edit-distance/)
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
-   插入一个字符
-   删除一个字符
-   替换一个字符
示例 1： 输入：word1 = "horse", word2 = "ros" 输出：3 解释： horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e')
```js
const minDistance = (word1, word2) => {
  //1.定义dp数组
  //dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。
  let dp = Array.from(Array(word1.length + 1), () => Array(word2.length + 1).fill(0));
  //2.设置dp[][]初值
  //dp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。
  //dp[i][0]就应该是i，对word1里的元素全部做删除操作，即：dp[i][0] = i;
  // 同理dp[0][j] = j;
  for (let i = 1; i <= word1.length; i++) {
    dp[i][0] = i;
  }
  for (let j = 1; j <= word2.length; j++) {
    dp[0][j] = j;
  }
  for (let i = 1; i <= word1.length; i++) {
    for (let j = 1; j <= word2.length; j++) {
      //如果(word1[i - 1] == word2[j - 1]) 那么说明不用任何编辑，dp[i][j] 就应该是 dp[i - 1][j - 1]
      if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        //看图1
        dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1);
      }
    }
  }
  return dp[word1.length][word2.length];
};
//看图2
minDistance('horse', 'ros')
```
![图一](https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20230102202615.png)
![](https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20230102202642.png)
#### [115不同子序列](https://leetcode.cn/problems/distinct-subsequences/solution/)
给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。
字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）
题目数据保证答案符合 32 位带符号整数范围。
示例 1：
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
rab bbit
rabb bit
rabbb it
```js
/**
 * @param {string} s
 * @param {string} t
 * @return {number}
 */
const numDistinct = (s, t) => {
  //1.定义dp数组：dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。
  let dp = Array.from(Array(s.length + 1), () => Array(t.length + 1).fill(0));
  //2.初始化dp dp[i][0]:把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1
  //dp[0][j]与之相反
  for (let i = 0; i <= s.length; i++) {
    dp[i][0] = 1;
  }
  for (let i = 1; i <= s.length; i++) {
    for (let j = 1; j <= t.length; j++) {
      if (s[i - 1] === t[j - 1]) {
        //相等的话，dp[i][j]可以有两部分组成。  一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]，  一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。
        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
      } else {
        //不相等的话，dp[i][j]只有一部分组成，不用s[i - 1]来匹配，即：dp[i - 1][j]
        dp[i][j] = dp[i - 1][j]
      }
    }
  }
  return dp[s.length][t.length];
};
```
![](https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20230102205850.png)
### 贪心
#### [1402做菜顺序](https://leetcode.cn/problems/reducing-dishes/)
一个厨师收集了他 n 道菜的满意程度 satisfaction ，这个厨师做出每道菜的时间都是 1 单位时间。
一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是 time[i] * satisfaction[i] 。
请你返回做完所有菜 「喜爱时间」总和的最大值为多少。
你可以按 任意 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。
示例 1：
输入：satisfaction = [-1,-8,0,5,-9]
输出：14
解释：去掉第二道和最后一道菜，最大的喜爱时间系数和为 (-1* 1 + 0* 2 + 5* 3 = 14) 。每道菜都需要花费 1 单位时间完成。
解题思路
排序
遍历左指针
遍历右指针并更新当前“喜爱时间”的最大值
```js
/**
 * @param {number[]} satisfaction
 * @return {number}
 */
const maxSatisfaction = (satis) => {
   const arr = satisfaction.sort((a, b) => a - b) //好货压轴
    let pre = 0
    let res = 0
    //暴力遍历出所有选择，在遍历右指针的时候并更新当前“喜爱时间”的最大值
    for (let i = 0; i < arr.length; i++) {
        pre = 0
        for (let j = i; j < arr.length; j++) {
            pre += satisfaction[j] * (j - i + 1)
            res = Math.max(res, pre)
        }
    }
    return res
}
```
#### [376. 摆动序列 ](https://leetcode.cn/problems/wiggle-subsequence/)
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。
例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。
示例 1:
输入: [1,7,4,9,2,5]
输出: 6
解释: 整个序列均为摆动序列。
```js
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var wiggleMaxLength = function(nums) {
  if(nums.length <= 1) return nums.length
  let res = 1
  let preDiff = 0
  let curDiff = 0
  for(let i = 0; i < nums.length - 1; i++) {
      curDiff = nums[i + 1] - nums[i]
      if((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {
          res++
          preDiff = curDiff
      }
  }
  return res
};
/*
时间复杂度：O(n)O(n)，其中 nn 是序列的长度。我们只需要遍历该序列一次。
空间复杂度：O(1)O(1)。我们只需要常数空间来存放若干变量。
*/
```

伪代码：
```shell
function wiggleMaxLength(nums)
  if length of nums <= 1 then
    return length of nums
  res := 1
  preDiff := 0
  curDiff := 0
  for i := 0 to length of nums - 1 do
  	begin
    curDiff = nums[i+1] - nums[i]
    if curDiff > 0 and preDiff <= 0 or curDiff < 0 and preDiff >= 0 then
      begin
      res := res+1
      preDiff := curDiff
      end
    end
  return res
```

### 分治
#### [53.最大字数组和](https://leetcode.cn/problems/maximum-subarray)
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
[解决方法](https://leetcode.cn/problems/maximum-subarray/solution/wu-chong-jie-fa-san-chong-yu-yan-java-javascript-2/)
```js
/*
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
  //贪心解法
  let res = -Infinity
  let count = 0
  for (let i = 0; i < nums.length; i++) {
    count += nums[i]
    if (count > result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置）
      result = count;
    }
    if (count <= 0) {// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
      count = 0
    }
  }
  return res
    //动态规划解法
  // let pre = 0, max = nums[0]
  // nums.map((num) => {
  //   pre = Math.max(pre + num, num)
  //   max = Math.max(max, pre)
  // })
  // return max
};
/* 分治解法
时间复杂度： O(nlogn) - n 是数组长度
空间复杂度： O(logn) - 因为调用栈的深度最多是logn。
 */
function LSS(list) {
  return helper(list, 0, list.length - 1);
}
function helper(list, m, n) {
  if (m === n) return list[m];
  let sum = 0;
  let lmax = -Number.MAX_VALUE;
  let rmax = -Number.MAX_VALUE;
  const mid = ((n - m) >> 1) + m;
  const l = helper(list, m, mid);
  const r = helper(list, mid + 1, n);
  for (let i = mid; i >= m; i--) {
    sum += list[i];
    if (sum > lmax) lmax = sum;
  }
  sum = 0;
  for (let i = mid + 1; i <= n; i++) {
    sum += list[i];
    if (sum > rmax) rmax = sum;
  }
  return Math.max(l, r, lmax + rmax);
}
console.log(LSS([-2,1,-3,4,-1,2,1,-5,4]));
```

### 回溯
#### [39.组合总和](https://leetcode.cn/problems/combination-sum/)
给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。
candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
对于给定的输入，保证和为 target 的不同组合数少于 150 个。
示例 1：
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function (candidates, target) {
  const res = []
  const path = []
  candidates.sort((a, b) => a - b)
  const dfs = (index, sum) => {
    if (sum === target) {
      res.push(Array.from(path))
      return
    }
    for (let i = index; i < candidates.length; i++) {
      const n = candidates[i]
      //如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历
      if (n > target - sum) break
      path.push(n)
      sum += n
      dfs(i, sum)
      //当满足递归终止条件时，将path[]和sum清零
      path.pop()
      sum -= n
    }
  }
  dfs(0, 0)
  return res
};
```

伪代码：
```shell

function combinationSum(candidates, target):
    res := []
    path := []
    sort candidates in ascending order
    function dfs(index, sum):
        if sum == target then
            add a copy of path to res
            return
        for i := index to end of candidates do
        	begin
            n := candidates[i]
            if n > target - sum then
                break
            end
            add n to path
            sum := sum + n
            dfs(i, sum)
            remove n from path
            sum := sum - n
        end
    dfs(0, 0)
    return res
exit

```


![](https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20230102211552.png)

## 补充题目
### 二、快递终端送货分配系统
question1伪代码：
```python
```
question2伪代码：
```python
question2(goods[0..n-1],k)
//求最少需要的趟数
//输入：goods为货物列表goods[1]为货物重量,k为每一趟最多承重量
//输出：最少需要的趟数
list<-[]
for i to n do:
    weight<-goods[i]
    min<-∞
    k<-0
    //遍历每一趟剩余可装的货物重量
    for j to list.size do:
        size<-list.get(j)
        if size-weight< min:
            min=size-weight
            k=j
    //判断是否需要增加一趟
    if min != ∞:
        remove<-list.get(k)
        list.remove(remove)
        list.add(remove-weight)
    else:
        list.add(100-weight)
//列表的长度即为总共需要的趟数
return list.size
```
question3伪代码：
```python
createHuffmanTree(value[0..n-1])
//构建哈夫曼树
//输入：节点的权值集合
//输出：哈夫曼树的根节点
nodes<-[]
for i to n:
    nodes.add(value[i])
while nodes.size>1:
    sort(nodes)
    //取出前两个权值最小的节点
    left<-nodes.get(0)
    right<-nodes.get(1)
    //创建新节点权值为两节点权值之和
    root<-left.val+right.val
    root.left<-left
    root.right<-right
    //新节点加入列表，左右子节点z
    nodes.add(root)
    nodes.remove(left)
    nodes.remove(right)
return nodes.get(0)
```
question4伪代码：
```
```
### 三、果园篱笆
#### 1. 问题描述

某大学ACM集训队，不久前向学校申请了一块空地，成为自己的果园。全体队员兴高采烈的策划方案，种植了大批果树，有梨树、桃树、香蕉……。后来，发现有些坏蛋，他们暗地里偷摘果园的果子，被ACM集训队队员发现了。因此，大家商量解决办法，有人提出：修筑一圈篱笆，把果园围起来，但是由于我们的经费有限，必须尽量节省资金，所以，我们要找出一种最合理的方案。由于每道篱笆，无论长度多长，都是同等价钱。所以，大家希望设计出来的修筑一圈篱笆的方案所花费的资金最少。有人已经做了准备工序哦，统计了果园里果树的位置，每棵果树分别用二维坐标来表示，进行定位。现在，他们要求根据所有的果树的位置，找出一个n边形的最小篱笆，使得所有果树都包围在篱笆内部，或者在篱笆边沿上。

#### 2. 解决问题所用的方法及基本思路

因为所用篱笆的价钱和长度没有关系，所以本题目可以转化为求给定坐标组成的集合的凸包。
Andrew算法：
1.  对点集按照横坐标进行排序。
2.  从左到右依次枚举每个点，并将其插入到凸包上。
3.  在插入点时，需要删除凸包上所有形成下凸壳的边，以确保凸包的凸性。
4.  重复步骤 2 和 3，直到所有的点都被插入到凸包上。
![](https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20230103000253.png)
![](https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20230103000311.png)
![](https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20230103000319.png)


分治法：
1.  将点集平分成两个子集，分别求出两个子集的凸包。
2.  在两个子集的凸包之间连接一条边，形成一个凸壳。
3.  将凸壳中不在最终凸包上的点删除，确保凸包的凸性。
4.  重复步骤 1 到 3，直到所有的点都被插入到凸包上。
暴力法：
1.  遍历所有的点，并尝试将两个点加入凸包中。
2.  在尝试加入之前，检查这两个点是否满足凸包的性质。这里使用了一个函数 `calculate` 来计算凸性关系。
3.  如果两个点满足凸包的性质，则将它们加入凸包中。
4.  在所有点都被枚举完之后，返回凸包点的集合。



#### 3. 采用的数据结构描述

Andrew算法：
Andrew 算法用于解决凸包问题主要使用的数据结构是一个数组。在具体实现中，需要开辟一个数组来保存凸包上的点。
在插入点的过程中，Andrew 算法还使用了一些辅助数据结构，如栈。当向凸包中插入一个点时，Andrew 算法需要删除凸包上所有形成下凸壳的边，因此可以使用栈来保存凸包上的点，方便删除。
使用这些数据结构的时间复杂度均为 O(1)，因此 Andrew 算法的总的时间复杂度仍然是 O(nlogn) 级别的。

暴力法：
Andrew 算法用于解决凸包问题主要使用的数据结构是一个数组。在具体实现中，需要开辟一个数组来保存凸包上的点。

#### 4.算法描述

Andrew算法：
```shell
function convexHull(points):
  points.sort((a, b) => a[0] - b[0])
  n = length(points)
  stack = []
  for i = 1 to n:
    while length(stack) >= 2 and cross(stack[length(stack) - 2], stack[length(stack) - 1], points[i]) <= 0:
      stack.pop()
    stack.push(points[i])
  for i = n to 1:
    while length(stack) >= t and cross(stack[length(stack) - 2], stack[length(stack) - 1], points[i]) <= 0:
      stack.pop()
    stack.push(points[i])
  stack.pop()
  return stack

```

蛮力法：
```shell
function bruteForce(points):
  convexHullPoints = new Set()
  for i = 1 to length(points):
    point1 = points[i]
    for j = i + 1 to length(points):
      point2 = points[j]
      oneSide = 0
      otherSide = 0
      for k = 1 to length(points):
        point = points[k]
        temp = calculate(point1, point2, point)
        if temp > 0:
          oneSide++
        else if temp < 0:
          otherSide++
      if oneSide == 0 or otherSide == 0:
        convexHullPoints.add(point1)
        convexHullPoints.add(point2)
  return convexHullPoints

```

#### 5.算法的时间空间复杂度分析

Andrew算法：
时间复杂度为 O(n * log(n))，其中 n 是点的数量，时间复杂度的瓶颈在于插入点的过程，每次插入点的时间复杂度为 O(n)，因此总的时间复杂度可达到 O(n^2)。由于在插入点之前将点集按照横坐标升序排序，则时间复杂度就可以降低到 O(nlogn)
空间复杂度为 O(n)，是因为需要开辟一个长度为 n 的数组来保存凸包上的点。

暴力法：
时间复杂度为 O(n^3)，这是因为在最外层的循环中枚举了所有的点，在第二层的循环中又枚举了所有的点，在第三层的循环中又遍历了所有的点。
空间复杂度为 O(n)，需要开辟一个长度为 n 的数组来保存凸包上的点。

#### 6.算法实例

输入：

![](file:///C:\Users\ljq0226\AppData\Local\Temp\ksohtml21812\wps2.jpg) 

输出：
![](https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20230102233650.png)




#### 五、基因序列比较
动态规划伪代码：
```python
dynamicProgramming(arr1[0..m-1],arr2[0..n-1])
//动态规划求两个基因序列的最佳得分
//getScore()用于获取两个相对的碱基得分
//输入：两个字符数组，代表两个基因序列
//输出：最佳得分
dp<-[0..m][0..n]
//初始化
for i<-1 to m+1 do 
    dp[i][0]<-getScore(arr1[i-1],'-')+dp[i-1][0]
for j<-1 to n+1 do
    dp[0][j]<-getScore('-',arr2[j-1])+dp[0][j-1]
//开始状态转移
for i<-1 to m+1 do
    for j<-1 to n+1 do
		dp[i][j]<-max(
            dp[i-1][j]+getScore(arr1[i-1],'-'),
            dp[i][j-1]+getScore('-',arr2[j-1]),
            dp[i-1][j-1]+getScore(arr1[i-1],arr2[j-1])
        )
return dp[m][n]
```
时间复杂度分析：
空间复杂度分析：
```js
const SCORING_MATRIX = {
  A: { A: 5, C: -1, G: -2, T: -1, "-": -3 },
  C: { A: -1, C: 5, G: -3, T: -2, "-": -4 },
  G: { A: -2, C: -3, G: 5, T: -2, "-": -2 },
  T: { A: -1, C: -2, G: -2, T: 5, "-": -1 },
  "-": { A: -3, C: -4, G: -2, T: -1, "-": 0 }
};
const tbody = document.querySelector('.tableList')
const res_du = document.querySelector('.res_du')
const res_str = document.querySelector('.res_str')
function align(s1, s2) {
  console.log(s1, s2);
  // 初始化dp数组
  const dp = Array(s1.length + 1).fill(null).map(() => Array(s2.length + 1).fill(0));
  // 首先对第一行和第一列进行初始化
  // 因为它们都是只能从一种状态变换过来，所以直接赋值即可
  for (let i = 1; i <= s1.length; i++) {
    dp[i][0] = SCORING_MATRIX[s1[i - 1]]["-"] + dp[i - 1][0];
  }
  for (let j = 1; j <= s2.length; j++) {
    dp[0][j] = SCORING_MATRIX["-"][s2[j - 1]] + dp[0][j - 1];
  }
  // 计算dp数组
  for (let i = 1; i <= s1.length; i++) {
    for (let j = 1; j <= s2.length; j++) {
      dp[i][j] = Math.max(
        dp[i - 1][j - 1] + SCORING_MATRIX[s1[i - 1]][s2[j - 1]],
        dp[i - 1][j] + SCORING_MATRIX[s1[i - 1]]["-"],
        dp[i][j - 1] + SCORING_MATRIX["-"][s2[j - 1]]
      );
    }
  }
  showBestWay(dp, s1, s2)
  showList(dp)
  console.log(dp);
  // 返回最后一个元素的值，即最大分数
  return dp[s1.length][s2.length];
}
align("AGTGATG", "GTTAG")
// 输出最佳对齐方法
function showBestWay(dp, arr1, arr2) {
  const m = dp.length;
  const n = dp[0].length;
  const list = [];
  // 手动把终点的索引加入列表，从终点向后回溯
  list.push([m - 1, n - 1]);
  dfs(dp, arr1, arr2, m - 1, n - 1, list);
  // 使用栈倒转列表，方便从起点开始描述路径
  const stack = [];
  for (let i = 0; i < best.length; i++) {
    stack.push(best[i]);
  }
  // 双指针，分别记录两个基因序列的索引
  let index1 = 0;
  let index2 = 0;
  // 使用两个StringBuilder分别保存两个基因序列
  const sb1 = [];
  const sb2 = [];
  // 记录当前的位置，初始值为起点
  let nowX = 0;
  let nowY = 0;
  while (stack.length > 0) {
    const pop = stack.pop();
    const x = pop[0];
    const y = pop[1];
    if (x > nowX && y > nowY) { // 向右下移动了
      sb1.push(arr1[index1++]);
      sb2.push(arr2[index2++]);
    } else if (x > nowX) { // 向下移动了
      sb1.push(arr1[index1++]);
      sb2.push("-");
    } else { // 向右移动了
      sb2.push(arr2[index2++]);
      sb1.push("-");
    }
    // 更新当前位置
    nowX = x;
    nowY = y;
  }
  res_du.innerHTML = `
  ${dp[m - 1][n - 1]}
  `
  res_str.innerHTML = `
  <p class=""> ${sb1.join("")}</p>
  <p class=""> ${sb2.join("")}</p>
  `
}
function dfs(dp, arr1, arr2, x, y, list) {
  // 当列表中的元素足够多时，停止搜索
  if (list.length === dp.length - 1) {
    best = [...list];
    return;
  }
  const dirs = [[-1, 0], [0, -1], [-1, -1]];
  const s = [SCORING_MATRIX[arr1[x - 1]]['-'],
  SCORING_MATRIX['-'][arr2[y - 1]],
  SCORING_MATRIX[arr1[x - 1]][arr2[y - 1]]]
  for (let i = 0; i < dirs.length; i++) {
    const x1 = x + dirs[i][0];
    const y1 = y + dirs[i][1];
    if (x1 < 0 || y1 < 0 || dp[x][y] - s[i] !== dp[x1][y1]) {
      continue;
    }
    const temp = [x1, y1];
    list.push(temp);
    dfs(dp, arr1, arr2, x1, y1, list);
    list.pop();
  }
}
function showList(dp) {
  tbody.innerHTML = ''
  for (let i = 0; i < dp.length; i++) {
    tbody.innerHTML += `
    <tr>
    </tr>
    `
    for (let j = 0; j < dp[0].length; j++) {
      tbody.children[i].innerHTML += `
      <td>${dp[i][j]}</td>
      `
    }
  }
}
function showGene() {
  const str1 = document.querySelector('.str1')
  const str2 = document.querySelector('.str2')
  align(str1.value, str2.value)
}
document.querySelector('.gene').addEventListener('click', showGene)
```
