
# 第二章 进程与线程

## 01 进程的引入

### 进程的概念
+ 为了真实反映系统的**独立性、并发性、动态性和相互制约**
	+ 动态性：进程是程序的一次执行过程
	+ 并发性：进程是可以和别的计算机**并发**执行的计算--》**提高CPU的利用率**
	+ 独立性： 进程是一个能**独立**运行的基本单位，是系统进行**资源分配****和**调度**的一个基本单位
	+ 异步性：多个进程并发执行，每个进程的相对速度不可预测

>进程(Process)定义为:"**并发执行**的程序在**一个**数据集合上的**执行过程**"

+ 单道程序的执行
	+ 顺序性 ：处理机的操作严格按规定顺序执行
	+ 封闭性 ：程序执行时，独占系统资源
	+ 可在现性 ：当初始条件相同时，程序多次执行的结果相同

多道程序的并发的执行
+ 间断性：  程序在并发执行时，形成了相互制约关系。相互制约将导致并发程序具有“执行—暂停—执行”这种间断性的活动规律
+ 失去封闭性：系统中的资源供多个程序共享，致使程序的运行失去了封闭性
+ 失去可再现性(的风险)

![[进程并发.excalidraw]]
### 并发执行的条件(Bernstein)
**Bernstein条件**
+ 读集：R(Pi)={a1,a2,......,am}程序Pi执行期间参考的变量集合
+ 写集：W(Pi)={b1,b2,......,bm}程序Pi执行期间改变的变量集合
+ 若两个程序P1，P2若满足：**R(P1)∩W(P2)∪R(P2)∩W(P1)∪W(P1)∩W(P2)={}**,则P1，P2并发执行，且具有可再现性
### 进程与程序的关系
+ 进程的动态性和程序的静态性
+ 进程的并发性和程序的顺序性
+ 进程的暂时性与程序的永久性
+ 结构特征
+ 进程与程序是密切相关的。


## 02进程的状态及组成
### 进程的基本状态
+ **创建** 
	+ 分配PCB结构
	+ 分配进程组，连接进程的父子关系
	+ 分配资源.......
+ **运行**：进程正在处理机上运行的状态
+ **就绪**：获得了除处理机外其他所有资源，等待调度的状态
+ **阻塞**：等待I/O操作或者某个同步事件而暂停运行的状态
+ **退出**：从运行状态中移除，使之不可能再运行

![](https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20220923084420.png)
+ **挂起**
	+ 内外存兑换的需要
	+ 用户调试程序的需要
	+ 实时系统中调节负载的需要


### 进程的组成
+ **栈**：一段系统存储单元，用于*保存程序调用时的参数*、**过程调用地址和系统调用地址**
+ **程序**：描述进程本身要完成的功能、
+ **数据**：程序需要操作的对象，一组存储单元
+ **进程控制块**（**PCB**，processcontrolblock）
	+ 为了**描述和记录进程的动态变化**，并使之能正确运行，为每个进程设置的**数据结构**
	+ 使程序能成为独立运行的单位，并可和其他进程并发执行。

####  进程控制块
  
+ **进程描述信息**
	+ 进程名
	+ 进程标识符（进程存在的唯一标识）
	+ 用户名
+ **处理机状态信息**
	+ 通用寄存器
	+ 指令计数器（程序计数器）
	+ 程序状态字寄存器（）
	+ 栈指针 
+ **进程控制和资源占有量信息**
	+ 程序入口地址
	+ 程序的外存地址
	+ 进程同步及通信机制
+ **进程调度信息**
	+ 进程状态
	+ 进程优先级
	+ 运行统计信息
	+ 进程阻塞原因



## 03 进程控制

#### 操作系统内核
+ cpu的两种工作状态:核心态(系统态，管态)和用户态(目态)
>为了防止**操作系统**及其**关键数据结构**被**用户程序**有意无意的**破坏**

+ **核心态**：具有较高的特权，能执行一切指令,能访问所有寄存及内存的所有区域。操作系统通常运行在核心态。
+ **用户态**：具有较低的特权执行状态,仅能执行规定指令,访问指定的寄存器和内存指定区域。用户程序通常运行在运行状态
+ 用户态-->核心态:程序调度(中断、异常)
+ 核心态-->用户态:设置程序状态

#### 内核与原语
+ 内核(设计层次)
	+ 系统将一些与硬件紧密相关的模块放入内核，内核主要功能包含:
		+ 时钟管理:分时轮询的时间片，产生中断信号
		+ 中断处理：系统调用、进程调度、设备操作都采用中断处理
		+ 原语处理：操作系统中一些最基本的操作
+ 原语
	+ 原语由若干条指令构成、用于完成一定功能的过程
	+ 原语是“原子操作”。即一个操作中的所有动作，**要么全做**，要么全不做。原子操作是一个不可分割的操作

#### 进程家族树
+ 系统允许一个进程**创建控制**另一个进程，前者为父进程,后者为子进程
+ 子进程可**继承**父进程的资源：文件、缓存区
+ 子进程撤销，将资源归还给父进程
+ 父进程撤销，将所有先前的子进程先撤销
![](https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20220923090737.png)

#### 进程控制包含的内容
##### 进程的创建
引起创建的操作事件
+ 用户的登录
+ 新作业进入系统
+ 提供服务
+ 应用请求
创建原语所需要的工作
1. 申请空白的PCB
2. 初始化PCB（进程的描述信息、处理机状态信息、进程控制信息）
3. 为进程分配资源、分配存储空间
4. 将新进程插入就绪队列
##### 进程的撤销
引起进程撤销的事件：
+ 进程正常结束
+ 进程异常结束(由于错误或者故障而被迫中止进程)
+ 外界干预
	+ 操作系统干预
	+ 父进程要求撤销
	+ 父进程被撤销
撤销原语所需要的工作:
+ 查找病撤销进程的PCB
+ 若进程处于执行状态,予以终止并进行进程调度
+ 若有子孙,予以终止
+ 归还资源
+ 从所在队列移除

##### 进程的阻塞与唤醒
+ 事件
	+ 请求系统服务
	+ 启动某种操作
	+ 数据尚未到达
	+ 无新工作可做
+ 阻塞原语需要做的工作
	+ 停止进程的执行
	+ 将进程插入到阻塞队列，改变进程中的PCB的状态(阻塞)
	+ 重新调度
+ 唤醒原语要做的工作
	+ 将进程从阻塞队列取下
	+ 插入到就绪队列的队尾
	+ 改变进程在PCB的状态

进程的挂起与激活

挂起原语要做的工作：
+ 检查被挂起进程的状态
+ 如进程处于就绪状态，将进程从就绪状态变为就绪挂起状态
+ 如进程处于阻塞状态，将进程从阻塞状态变为阻塞挂起状态
+ 如进程正在运行，将进程变为就绪挂起状态，并重新调度
激活原语要做的工作：
+ 检查被激活进程的状态
+ 如进程处于就绪挂起状态，将进程从就绪挂起状态变为就绪状态
+ 如进程处于阻塞挂起状态，将进程从阻塞挂起状态变为阻塞状态
+ 若系统为抢占式系统，则进行进程调度


## 04 线程(Thread)

+ 线程的引入
	 + 进程是**拥有资源**的**独立**单位
	 + 进程是**独立调度和分派**的**基本**单位

>由于进程是资源owner,在进程的**创建、撤销和切换**中系统位置付出**较大的事件、空间开销**。因此，系统所设置的进程数量不宜过多

进程和线程的关系
+ 进程包含线程
	+ 进程-->程序
	+ 线程-->函数

#### 定义
+ 线程是进程中的一个**实体**，是**系统独立调度和分派**的**基本**单位,表示进程中的一个**控制点**,执行一系列指令
	+ 当操作系统引入线程之后，线程成为了调度和分派的基本单位，而不再是进程
	+ 不是所有的OS都支持线程(UNIX不支持，Windows支持)
#### 线程模型


+ 进程是资源的拥有者
+ 线程基本不拥有资源，只有TCB及堆栈指针
![](https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20220923091441.png)


#### 线程控制块(TCB)的组成
+ 线程标识符：它是线程的唯一标识
+ 处理机状态信息：描述处理机状态信息的一组寄存器
+ 栈指针：每个线程有**用户栈**和**核心栈**两个。线程在用户态下运行时使用自己的用户栈，当转到核心态运行时使用核心栈
+ 私有存储区：存放现场保护信息和其他与该线程相关的的统计信息

#### 线程的状态
> 线程状态与进程状态相似


#### 线程的控制
+ 线程的创建 
	+ 调用线程库中的系统调用创建线程
	+ 分配进程控制块、栈等必要数据结构
+ 线程的撤销
	+ 通过调用线程库中的系统调用撤销线程
+ 线程的等待
	+ 线程通过调用线程库中的系统调用等待其它的某个线程，使该线程阻塞
+ 线程的让权
	+ 线程通过调用线程库中的系统调用来实现自愿放弃CPU

#### 进程和线程的区别  ✅
+ 调度
	+ 线程调度快，需要空间小
	+ 进程因拥有资源，调度时因负担过重而缓慢
+ 并发性
	+ 在引入线程的操作系统中，不仅进程之间可以并发执行，一个进程中的多个线程之间也可以并发执行
+ 拥有资源
	+ 进程是资源的拥有者
+ 系统的开销
	+ 进程切换的开销远远大于线程切换的开销， 线程的切换省去了资源的回收

#### 线程的实现
##### 用户级线程
+ 应用程序通过**线程库**设计多线程程序，线程库是用于管理用户级线程的**软件包**
+ 线程的创建、撤销和切换，都不利于系统调用来实现。线程与内核无关，内核也不知道到线程的存在
##### 内核级线程
+ 依赖于内核，线程的创建、撤销和切换都由内核实现。在内核中由线程控制块(TCB).内核根据TCB感知线程的存在，并对线程进行控制


![](https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20220923092305.png)

##### 用户级线程与内核级线程的比较
+ 调度与切换速度
	+   用户级线程的切换，因发生在一个应用进程之间，因此不仅无须通过中断进入OS内核，而且切换的规则也比较简单。
	+   用户级线程比内核级线程切换速度快
+   系统调用
	+   用户级线程在调用系统调用时，系统将看成是其所在进程的行为。而内核级线程的系统调用是以线程为单位。因此比较轻装。
	+   用户级线程不如内核级线程
+   线程执行时间
	+   用户级线程不如内核级线程合理
##### 组合的方法
+ 由内核支持的用户线程。一个进程可以有一个或多个轻量级线程，**每个轻量级线程由一个单独的内核级线程来支持**
![](https://obs-pic-1309372570.cos.ap-chongqing.myqcloud.com/20220923092642.png)


#### 多线程问题
+ **线程的取消**:线程在完成任务之前终止
	+ 立即取消-->线程马上终止，系统收回所有资源
	+ 延迟取消-->系统需要检查线程是否处于安全点，处于安全点则取消，系统收回所有资源

+ **信号处理**
	+ 通过信号来传递发生某个特定事件的信息
		+ 同步信号：信号的发生和接收是同一进程
		+ 异步信号：信号由进程外部的事件产生
	+ 多线程信号发送有以下选择：
		+ 发送到信号所使用的线程
		+ 发送到进程内的所有线程
		+ 发送到进程内某个固定线程
		+ 规定一个线程用以接收进程发出的所有信号

+ **线程池**
	+ 对于一个Web服务器程序，每当服务器接受到用户请求，就需要为之创建一个线程来处理
	+ 潜在风险：无法限制并发执行的线程数量，无限制的线程会耗尽系统资源
	+ 解决办法：线程池。预先创建一定数量的线程，“申请->使用->释放”，线程池中没有空闲线程，则服务器等待
	+ 优点处理快、对系统资源进行了限制和保护



