# Nest.js

[模版](https://github.com/yw0525/nest-server-starter)

[搭建nest](https://juejin.cn/post/7044708915438682148#heading-5)

## 创建项目

`yarn add -g @nestjs/cli` 全局安装nest.js

`nest new project-name` 创建一个新项目

## 快速搭建模块(CRUD生成器)

`nest g resource` MoudleName

像这样传递`--no-spec`参数`nest g resource users --no-spec`来避免生成测试文件。

命令不仅仅生成所有Nestjs构件模块(模块，服务，控制器类)module controller service ，也生成实体类，`DTO`类和测试(.spec)文件。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/00241673-520f-4da9-877e-eae250b1f472/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7fcb8ab4-bcf1-4eef-816b-4837ffb4b7f5/Untitled.png)

生成后记得 yarn一下或npm i 一下 安装一下依赖包

## 连接数据库

使用的是mysql数据库

### TypeORM

`node.js`世界中最成熟的对象关系映射器ORM ，用来操作数据库的

ORM技术（`Object-Relational Mapping`）,把关系数据库的变结构映射到对象上

安装依赖 `yarn add @nestjs/typeorm typeorm mysql2 -S`

### @nestjs/config 使用环境变量 配置数据库

`@nestjs/config`依赖于dotenv，可以通过key=value形式配置环境变量，项目会默认加载根目录下的.env文件，我们只需在app.module.ts中引入ConfigModule，使用ConfigModule.forRoot()方法即可，然后`ConfigService`读取相关的配置变量。

安装依赖 `yarn add @nestjs/config`

在src同级目录下创建`.env` 和 `.env.prod` 文件配置数据库信息

```js
// 数据库地址
DB_HOST=localhost  
// 数据库端口
DB_PORT=3306
// 数据库登录名
DB_USER=root
// 数据库登录密码
DB_PASSWD=root
// 数据库名字
DB_DATABASE=blog
```

然后在src同级目录下创建config文件夹 创建env.ts文件来读取.env .env.prod文件配置信息并导出

```ts
// env.ts
import * as fs from 'fs';
import * as path from 'path';
const isProd = process.env.NODE_ENV === 'production';

function parseEnv() {
  const localEnv = path.resolve('.env');
  const prodEnv = path.resolve('.env.prod');

  if (!fs.existsSync(localEnv) && !fs.existsSync(prodEnv)) {
    throw new Error('缺少环境配置文件');
  }

  const filePath = isProd && fs.existsSync(prodEnv) ? prodEnv : localEnv;
  return { path:filePath };
}
export default parseEnv();
```

然后在`app.module.ts`中连接数据库：

```ts
import { TypeOrmModule } from '@nestjs/typeorm';
import { ConfigService, ConfigModule } from '@nestjs/config';
import envConfig from '../config/env';

@Module({
  imports: [
    ConfigModule.forRoot({ 
    isGlobal: true,  // 设置为全局
    envFilePath: [envConfig.path] 
   }),
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => ({
        type: 'mysql', // 数据库类型
        entities: ['dist/**/*.entity{.ts,.js}'], // 数据表实体 或者逐一引入 
        host: configService.get('DB_HOST', 'localhost'), // 主机，默认为localhost
        port: configService.get<number>('DB_PORT', 3306), // 端口号
        username: configService.get('DB_USER', 'root'),   // 用户名
        password: configService.get('DB_PASSWORD', 'root'), // 密码
        database: configService.get('DB_DATABASE', 'blog'), //数据库名
        timezone: '+08:00', //服务器上配置的时区
        synchronize: true, //根据实体自动创建数据库表， 生产环境建议关闭
      }),
    }),
    PostsModule,
  ],
 ...
})
export class AppModule {}
```

其中引入实体类entities 有3中方式

```ts
方式一：单独定义
import { UserEntity } from '@src/...'
{
	entities: [UserEntity, OtherEntity],
}
方式二: 自动加载
TypeOrmModule.forRoot({
  //...
  autoLoadEntities: true,
}),]
方式3:配置路径自动引入
TypeOrmModule.forRoot({
      //...
      entities: ['dist/**/*.entity{.ts,.js}'],
    }),]
```

## 配置异常过滤器

`nest g filter core/filter/http-exception` 在src/core/filter下创建http-exception.filttler.ts

过滤器代码实现

```tsx
import {ArgumentsHost,Catch, ExceptionFilter, HttpException} from '@nestjs/common';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp(); // 获取请求上下文
    const response = ctx.getResponse(); // 获取请求上下文中的 response对象
    const status = exception.getStatus(); // 获取异常状态码

    // 设置错误信息
    const message = exception.message
      ? exception.message
      : `${status >= 500 ? 'Service Error' : 'Client Error'}`;
    const errorResponse = {
      data: {},
      message: message,
      code: -1,
    };

    // 设置返回的状态码， 请求头，发送错误信息
    response.status(status);
    response.header('Content-Type', 'application/json; charset=utf-8');
    response.send(errorResponse);
  }
}
```

## 配置拦截器

`nest g interceptor core/interceptor/transform` 在src/core/interceptor下创建transform.interceptor.ts 文件

拦截器代码实现：

```tsx
import {CallHandler, ExecutionContext, Injectable,NestInterceptor,} from '@nestjs/common';
import { map, Observable } from 'rxjs';

@Injectable()
export class TransformInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map((data) => {
        return {
          data,
          code: 0,
          msg: '请求成功',
        };
      }),
    );
  }
}
```

## **配置接口文档Swagger**

安装依赖 `yarn add @nestjs/swagger swagger-ui-express -S`

## 配置管道 数据验证

管道是具有 `@Injectable()` 装饰器的类。管道应实现 `PipeTransform` 接口。

管道有两个类型:

-   **转换**：管道将输入数据转换为所需的数据输出
-   **验证**：对输入数据进行验证，如果验证成功继续传递; 验证失败则抛出异常;

> 管道在异常区域内运行。这意味着当抛出异常时，它们由核心异常处理程序和应用于当前上下文的 异常过滤器 处理。当在 Pipe 中发生异常，controller 不会继续执行任何方法。

什么意思呢， 通俗来讲就是，对请求接口的入参进行验证和转换的前置操作，验证好了我才会将内容给到路由对应的方法中去，失败了就进入异常过滤器中。

`Nest.js`自带了三个开箱即用的管道：`ValidationPipe`、`ParseIntPipe`和`ParseUUIDPipe`, 其中`ValidationPipe` 配合`class-validator`就可以完美的实现我们想要的效果（对参数类型进行验证，验证失败抛出异常）。

管道验证操作通常用在`dto`这种传输层的文件中,用作验证操作。首先我们安装两个需要的依赖包：`class-transformer`和`class-validator`

```
npm install class-validator class-transformer -S
```

然后在`create-post.dto.ts`文件中添加验证, 完善错误信息提示：

```tsx
import { IsNotEmpty } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
export class CreateUserDto {
  //class-validator还有其它很多限制条件 请查阅官网
  @ApiProperty({ description: '用户名' })
  @IsNotEmpty({ message: '请输入用户名' })
  username: string;

  @ApiProperty({ description: '密码' })
  @IsNotEmpty({ message: '请输入密码' })
  password: string;

  @ApiProperty({ description: '用户头像', default: '' })
  avatar: string;
}

```

## 在main.ts中应用以上 配置

```tsx
import { TransformInterceptor } from './core/interceptor/transform.interceptor';
import { HttpExceptionFilter } from './core/filter/http-exception.filter';
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { NestExpressApplication } from '@nestjs/platform-express';
import { AppModule } from './app.module';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import { logger } from '../src/core/middleware/logger.middleware';
async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);
  //app.setGlobalPrefix('api'); // 全局路由前缀
  app.useGlobalFilters(new HttpExceptionFilter()); //应用过滤器
  app.useGlobalInterceptors(new TransformInterceptor()); //应用拦截器
  app.useGlobalPipes(new ValidationPipe()); //应用管道
  app.use(logger); //应用日志管理
  const config = new DocumentBuilder()
    .setTitle('XX平台')
    .setDescription('XX平台接口文档')
    .setVersion('1.0')
    .addBearerAuth()
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('docs', app, document); //配置swagger基本信息
  await app.listen(8080);
}
bootstrap();
```

-   用户注册
    
    用户实体类如下
    
    ```tsx
    //    posts/posts.entity.ts
    import { Exclude } from 'class-transformer';
    import { BeforeInsert, Column, Entity, PrimaryGeneratedColumn } from 'typeorm';
    import * as bcrypt from 'bcryptjs';
    @Entity('user')
    export default class User {
      @PrimaryGeneratedColumn()
      id: number; // 标记为主列，值自动生成
    
      @Column({ length: 20 })
      username: string;
    
      @Exclude() //对返回数据实现过滤password字段
      @Column({ length: 20 })
      password: string;
    
      @Column()
      avatar: string;
    
      @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
      create_time: Date;
    
      @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
      update_time: Date;
      //对密码进行加密处理 需加载bcryptjs包
      @BeforeInsert()
      async encryptPwd() {
        if (!this.password) return;
        this.password = await bcrypt.hashSync(this.password, 10);
      }
    }
    ```
    
    实现user.service.ts逻辑
    
    ```tsx
    import { User } from './entities/user.entity';
    import { Injectable, HttpException, HttpStatus } from '@nestjs/common';
    import { InjectRepository } from '@nestjs/typeorm';
    import { CreateUserDto } from './dto/create-user.dto';
    import { Repository } from 'typeorm';
    
    @Injectable()
    export class UserService {
      constructor(
        @InjectRepository(User)
        private userRepository: Repository<User>,
      ) {}
      async register(createUser: CreateUserDto) {
        const { username } = createUser;
    
        const existUser = await this.userRepository.findOne({
          where: { username },
        });
        if(existUser){
            throw new HttpException("用户名已存在", HttpStatus.BAD_REQUEST)
        }
    
        const newUser = await this.userRepository.create(createUser)
        return await this.userRepository.save(newUser);
      }
    }
    
    ```
    
    在user.controller中调用注册方法
    
    ```tsx
    import {
      Controller,
      Get,
      Post,
      Body,
      UseInterceptors,
      ClassSerializerInterceptor,
    } from '@nestjs/common';
    import { UserService } from './user.service';
    import { CreateUserDto } from './dto/create-user.dto';
    import { UpdateUserDto } from './dto/update-user.dto';
    import { ApiOperation, ApiResponse } from '@nestjs/swagger';
    @Controller('user')
    export class UserController {
      constructor(private readonly userService: UserService) {}
    
      @ApiOperation({ summary: '注册用户' })
      @ApiResponse({ status: 201, type: CreateUserDto })
      @UseInterceptors(ClassSerializerInterceptor) //请求返回的数据中，就不会包含password这个字段。
      @Post('register')
      register(@Body() createUser: CreateUserDto) {
        return this.userService.register(createUser);
      }
    }
    ```
    
    ### 对密码进行保护
    
    方法一
    
    修改service中返回逻辑 ，不直接将密码返回
    
    方法二
    
    使用`class-transformer`提供的`Exclude`来序列化，对返回的数据实现过滤掉`password` 字段的效果。首先在`user.entity.ts`中使用`@Exclude`装饰：
    
    接着在对应请求的地方标记使用`ClassSerializerInterceptor`，此时，`POST /api/user/register`这个请求返回的数据中，就不会包含`password`这个字段。
    
    此时可以不用像方法1那样，修改`user.service.ts` 中的逻辑。如果你想让该`Controller` 中所有的请求都不包含`password` 字段， 那可以直接用`ClassSerializerInterceptor` 标记类。